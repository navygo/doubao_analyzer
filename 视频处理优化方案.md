# è±†åŒ…åª’ä½“åˆ†æAPIæœåŠ¡å™¨è§†é¢‘å¤„ç†ä¼˜åŒ–æ–¹æ¡ˆ

## æ¦‚è¿°

æ ¹æ®ç³»ç»Ÿæ—¥å¿—åˆ†æï¼Œè§†é¢‘å¤„ç†è¿‡ç¨‹å­˜åœ¨æ€§èƒ½ç“¶é¢ˆï¼Œä¸»è¦è¡¨ç°åœ¨å¸§æå–å’ŒAPIè¯·æ±‚é˜¶æ®µã€‚æœ¬æ–‡æ¡£æä¾›äº†é’ˆå¯¹æ€§çš„ä¼˜åŒ–æ–¹æ¡ˆï¼Œæ—¨åœ¨æé«˜è§†é¢‘å¤„ç†é€Ÿåº¦ï¼Œé™ä½èµ„æºæ¶ˆè€—ï¼ŒåŒæ—¶ä¿æŒåˆ†æè´¨é‡ã€‚

## é—®é¢˜åˆ†æ

### 1. æ€§èƒ½ç“¶é¢ˆ

ä»æ—¥å¿—ä¸­å¯ä»¥çœ‹å‡ºä»¥ä¸‹é—®é¢˜ï¼š

1. **å¸§æå–è€—æ—¶è¾ƒé•¿**ï¼šè§†é¢‘å¸§æå–å¹³å‡è€—æ—¶2-3ç§’ï¼Œå æ•´ä¸ªå¤„ç†è¿‡ç¨‹çš„å¤§éƒ¨åˆ†æ—¶é—´ã€‚
2. **APIè¯·æ±‚å»¶è¿Ÿ**ï¼šé¦–æ¬¡APIè¯·æ±‚å»¶è¿Ÿè¾ƒé«˜ï¼ˆçº¦10ç§’ï¼‰ï¼Œåç»­è¯·æ±‚é€Ÿåº¦è¾ƒå¿«ï¼ˆçº¦0.3-0.5ç§’ï¼‰ï¼Œè¡¨æ˜å­˜åœ¨å†·å¯åŠ¨é—®é¢˜ã€‚
3. **èµ„æºåˆ©ç”¨ä¸å……åˆ†**ï¼šè™½ç„¶ä½¿ç”¨äº†CUDAç¡¬ä»¶åŠ é€Ÿï¼Œä½†æœªå……åˆ†åˆ©ç”¨GPUèµ„æºã€‚
4. **å¸§é‡‡æ ·ç­–ç•¥ä¸å¤Ÿæ™ºèƒ½**ï¼šå›ºå®šçš„é‡‡æ ·ç­–ç•¥ä¸é€‚åº”ä¸åŒé•¿åº¦å’Œç±»å‹çš„è§†é¢‘ã€‚

### 2. ä»£ç é—®é¢˜

é€šè¿‡åˆ†æVideoKeyframeAnalyzer.cppï¼Œå‘ç°ä»¥ä¸‹å¯ä¼˜åŒ–ç‚¹ï¼š

1. **FFmpegå‘½ä»¤å‚æ•°ä¸å¤Ÿä¼˜åŒ–**ï¼šå½“å‰å‚æ•°ç»„åˆå¯èƒ½å¯¼è‡´ä¸å¿…è¦çš„å¤„ç†å¼€é”€ã€‚
2. **çº¿ç¨‹æ± åˆ©ç”¨ç‡ä½**ï¼šè™½ç„¶å®ç°äº†çº¿ç¨‹æ± ï¼Œä½†åœ¨æŸäº›åœºæ™¯ä¸‹å¯èƒ½å­˜åœ¨çº¿ç¨‹ç©ºé—²ã€‚
3. **å†…å­˜ç®¡ç†ä¸å¤Ÿé«˜æ•ˆ**ï¼šBase64ç¼–ç å’Œå›¾åƒå¤„ç†å¯èƒ½å­˜åœ¨å†…å­˜æµªè´¹ã€‚
4. **ä¸´æ—¶æ–‡ä»¶å¤„ç†**ï¼šé¢‘ç¹åˆ›å»ºå’Œåˆ é™¤ä¸´æ—¶æ–‡ä»¶å¯èƒ½å½±å“æ€§èƒ½ã€‚

## ä¼˜åŒ–æ–¹æ¡ˆ

### 1. FFmpegå‘½ä»¤ä¼˜åŒ–

#### 1.1 é’ˆå¯¹ä¸åŒè§†é¢‘ç¼–ç æ ¼å¼çš„ä¼˜åŒ–ç­–ç•¥

```cpp
// åœ¨VideoKeyframeAnalyzer::extract_keyframesä¸­ä¼˜åŒ–FFmpegå‘½ä»¤
std::string get_optimized_extract_cmd(
    const std::string& video_url,
    const std::string& codec,
    int max_frames,
    const std::string& output_pattern,
    double video_duration = 0)
{
    int available_threads = std::min(8, static_cast<int>(std::thread::hardware_concurrency()));

    std::stringstream cmd;
    cmd << "ffmpeg -threads " << available_threads << " ";

    // æ ¹æ®è§†é¢‘æ—¶é•¿åŠ¨æ€è°ƒæ•´é‡‡æ ·ç­–ç•¥
    std::string filter;
    if (video_duration > 300) {  // é•¿è§†é¢‘ > 5åˆ†é’Ÿ
        if (codec == "hevc" || codec == "h265") {
            filter = "select='gt(scene,0.12)+eq(pict_type\,I)+not(mod(n\,60))', ";
        } else {
            filter = "select='eq(pict_type\,I)+not(mod(n\,50))+gt(scene,0.15)', ";
        }
    } else if (video_duration > 120) {  // ä¸­è§†é¢‘ 2-5åˆ†é’Ÿ
        if (codec == "hevc" || codec == "h265") {
            filter = "select='gt(scene,0.15)+eq(pict_type\,I)+not(mod(n\,30))', ";
        } else {
            filter = "select='eq(pict_type\,I)+not(mod(n\,25))+gt(scene,0.2)', ";
        }
    } else {  // çŸ­è§†é¢‘ < 2åˆ†é’Ÿ
        if (codec == "hevc" || codec == "h265") {
            filter = "select='gt(scene,0.2)+eq(pict_type\,I)+not(mod(n\,15))', ";
        } else {
            filter = "select='eq(pict_type\,I)+not(mod(n\,10))+gt(scene,0.25)', ";
        }
    }

    // æ™ºèƒ½ç¼©æ”¾å’Œå¡«å……ï¼Œä¿æŒå®½é«˜æ¯”
    filter += "scale='min(384,iw):min(384,ih)':"
              "force_original_aspect_ratio=decrease,"
              "pad=384:384:(ow-iw)/2:(oh-ih)/2:color=black";

    // ç¡¬ä»¶åŠ é€Ÿå’Œè¾“å‡ºé€‰é¡¹
    cmd << "-hwaccel cuda "
        << "-hwaccel_output_format cuda "
        << "-extra_hw_frames 2 "
        << "-i "" << video_url << "" "
        << "-vf "" << filter << "" "
        << "-vsync vfr "
        << "-frames:v " << max_frames << " "
        << "-q:v 1 "  // é«˜è´¨é‡JPEG
        << "-loglevel error "  // åªæ˜¾ç¤ºé”™è¯¯
        << "-stats "  // æ˜¾ç¤ºè¿›åº¦ç»Ÿè®¡
        << "-y "" << output_pattern << """;

    return cmd.str();
}
```

#### 1.2 æ”¹è¿›å…³é”®å¸§æå–é€»è¾‘

```cpp
// ä¼˜åŒ–extract_keyframeså‡½æ•°
std::vector<std::string> VideoKeyframeAnalyzer::extract_keyframes(
    const std::string &video_url,
    int max_frames,
    const std::string &output_format)
{
    std::vector<std::string> frames_base64;

    try {
        // åˆ›å»ºä¸´æ—¶è¾“å‡ºæ–‡ä»¶è·¯å¾„
        std::string output_pattern = temp_dir_ + "/keyframe_%03d." + output_format;

        // å…ˆè·å–è§†é¢‘ç¼–ç æ ¼å¼å’Œå…ƒæ•°æ®
        std::string codec_check_cmd = "ffprobe -v error -select_streams v:0 -show_entries stream=codec_name -of csv "" + video_url + """;
        std::string codec_result = execute_command(codec_check_cmd);
        std::string codec = "";

        // è§£æç¼–ç æ ¼å¼
        if (codec_result.find("h264") != std::string::npos) {
            codec = "h264";
        } else if (codec_result.find("hevc") != std::string::npos) {
            codec = "hevc";
        }

        // è·å–è§†é¢‘å…ƒæ•°æ®
        VideoMetadata metadata = get_video_metadata(video_url);

        // æ ¹æ®è§†é¢‘æ—¶é•¿å’Œç¼–ç æ ¼å¼æ„å»ºä¼˜åŒ–å‘½ä»¤
        std::string cmd = get_optimized_extract_cmd(
            video_url, codec, max_frames, output_pattern, metadata.duration);

        // æ‰§è¡Œå‘½ä»¤å¹¶è®¡æ—¶
        auto start_time = std::chrono::high_resolution_clock::now();
        execute_command(cmd);
        auto end_time = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end_time - start_time).count();

        std::cout << "â±ï¸ [è€—æ—¶] å¸§æå–è€—æ—¶: " << duration / 1000.0 << " ç§’" << std::endl;

        // æ”¶é›†æ‰€æœ‰æå–çš„å¸§æ–‡ä»¶è·¯å¾„
        std::vector<std::string> frame_paths;
        for (int i = 1; i <= max_frames; ++i) {
            std::string frame_path = temp_dir_ + "/keyframe_" +
                                    (i < 10 ? "00" : (i < 100 ? "0" : "")) +
                                    std::to_string(i) + "." + output_format;
            if (std::filesystem::exists(frame_path)) {
                frame_paths.push_back(frame_path);
            }
        }

        // ä½¿ç”¨å¹¶å‘å¤„ç†è¿™äº›å¸§
        auto concurrent_start = std::chrono::high_resolution_clock::now();
        frames_base64 = process_frames_concurrently(frame_paths);
        auto concurrent_end = std::chrono::high_resolution_clock::now();
        auto concurrent_duration = std::chrono::duration_cast<std::chrono::milliseconds>(concurrent_end - concurrent_start).count();

        std::cout << "å¹¶å‘å¸§å¤„ç†è€—æ—¶: " << concurrent_duration / 1000.0 << " ç§’" << std::endl;

        // å¦‚æœå…³é”®å¸§æ•°é‡ä¸è¶³ï¼Œä½¿ç”¨é‡‡æ ·æ–¹æ³•è¡¥å……
        if (frames_base64.size() < 3) {
            std::cout << "å…³é”®å¸§æ•°é‡ä¸è¶³(" << frames_base64.size() << ")ï¼Œä½¿ç”¨é‡‡æ ·æ–¹æ³•è¡¥å……åˆ°3å¸§" << std::endl;

            if (metadata.duration > 0) {
                // è®¡ç®—éœ€è¦è¡¥å……çš„å¸§æ•°
                int remaining_frames = 3 - frames_base64.size();

                // è®¡ç®—é‡‡æ ·é—´éš”
                double interval = metadata.duration / (remaining_frames + 1);

                // ä¸ºæ¯ä¸ªé‡‡æ ·ç‚¹åˆ›å»ºä¸´æ—¶æ–‡ä»¶è·¯å¾„
                std::vector<std::string> sample_paths;
                for (int i = 1; i <= remaining_frames; ++i) {
                    std::string sample_path = temp_dir_ + "/sample_" +
                                            (i < 10 ? "00" : (i < 100 ? "0" : "")) +
                                            std::to_string(i) + ".jpg";
                    sample_paths.push_back(sample_path);
                }

                // æ„å»ºFFmpegå‘½ä»¤
                std::string sample_cmd = "ffmpeg -hwaccel cuda -i "" + video_url + """;

                // æ·»åŠ é‡‡æ ·æ—¶é—´ç‚¹
                for (int i = 0; i < remaining_frames; ++i) {
                    double timestamp = (i + 1) * interval;
                    sample_cmd += " -ss " + std::to_string(timestamp) + 
                                 " -vframes 1 "" + sample_paths[i] + """;
                }

                sample_cmd += " -y";

                // æ‰§è¡Œå‘½ä»¤
                execute_command(sample_cmd);

                // ä½¿ç”¨å¹¶å‘å¤„ç†è¿™äº›é‡‡æ ·å¸§
                std::vector<std::string> sample_frames = process_frames_concurrently(sample_paths);

                // å°†å¤„ç†å¥½çš„é‡‡æ ·å¸§æ·»åŠ åˆ°ç»“æœä¸­
                for (const auto &frame : sample_frames) {
                    if (!frame.empty()) {
                        frames_base64.push_back(frame);
                    }
                }
            }
        }

        std::cout << "æˆåŠŸæå– " << frames_base64.size() << " ä¸ªå…³é”®å¸§" << std::endl;

        // è¾“å‡ºç»Ÿè®¡ä¿¡æ¯
        if (metadata.total_frames > 0) {
            double keyframe_ratio = (static_cast<double>(frames_base64.size()) / metadata.total_frames) * 100;

            std::cout << "ğŸ“Š [ç»Ÿè®¡] è§†é¢‘æ€»å¸§æ•°: " << metadata.total_frames << std::endl;
            std::cout << "ğŸ“Š [ç»Ÿè®¡] æŠ½å–å…³é”®å¸§æ•°: " << frames_base64.size() << std::endl;
            std::cout << "ğŸ“Š [ç»Ÿè®¡] æŠ½å–å¸§å æ€»å¸§æ•°æ¯”ä¾‹: " << std::fixed << std::setprecision(2)
                      << keyframe_ratio << "%" << std::endl;
        }
    }
    catch (const std::exception &e) {
        std::cerr << "æå–å…³é”®å¸§å¤±è´¥: " << e.what() << std::endl;
    }

    return frames_base64;
}
```

### 2. çº¿ç¨‹æ± å’Œå¹¶å‘ä¼˜åŒ–

#### 2.1 ä¼˜åŒ–çº¿ç¨‹æ± é…ç½®

```cpp
// åœ¨VideoKeyframeAnalyzeræ„é€ å‡½æ•°ä¸­ä¼˜åŒ–çº¿ç¨‹æ± åˆå§‹åŒ–
VideoKeyframeAnalyzer::VideoKeyframeAnalyzer()
{
    if (!create_temp_directory()) {
        throw std::runtime_error("æ— æ³•åˆ›å»ºä¸´æ—¶ç›®å½•");
    }
    std::cout << "ä¸´æ—¶ç›®å½•: " << temp_dir_ << std::endl;

    // ä¼˜åŒ–çº¿ç¨‹æ± å¤§å°ï¼Œè€ƒè™‘ç³»ç»Ÿèµ„æº
    int hardware_threads = std::thread::hardware_concurrency();
    int optimal_threads = std::min(hardware_threads, 8); // é™åˆ¶æœ€å¤§çº¿ç¨‹æ•°ä¸º8
    initialize_thread_pool(optimal_threads);

    std::cout << "âœ… å·²åˆå§‹åŒ–çº¿ç¨‹æ± ï¼Œçº¿ç¨‹æ•°: " << optimal_threads << std::endl;
}
```

#### 2.2 ä¼˜åŒ–å¸§å¤„ç†å¹¶å‘é€»è¾‘

```cpp
// ä¼˜åŒ–process_frames_concurrentlyå‡½æ•°
std::vector<std::string> VideoKeyframeAnalyzer::process_frames_concurrently(
    const std::vector<std::string> &frame_paths,
    int max_concurrency)
{
    // é™åˆ¶å¹¶å‘æ•°ï¼Œé¿å…èµ„æºäº‰ç”¨
    int actual_concurrency = std::min(max_concurrency, 
                                      static_cast<int>(worker_threads_.size()));

    std::vector<std::future<std::string>> futures;
    std::vector<std::string> results;

    // æ‰¹é‡æäº¤ä»»åŠ¡ï¼Œé¿å…é˜Ÿåˆ—è¿‡è½½
    const int batch_size = 4; // æ¯æ‰¹å¤„ç†4ä¸ªå¸§
    for (size_t i = 0; i < frame_paths.size(); i += batch_size) {
        size_t end_idx = std::min(i + batch_size, frame_paths.size());

        // æäº¤å½“å‰æ‰¹æ¬¡çš„ä»»åŠ¡
        for (size_t j = i; j < end_idx; ++j) {
            // ä½¿ç”¨lambdaå‡½æ•°æ•è·thisæŒ‡é’ˆï¼Œä»¥ä¾¿è°ƒç”¨æˆå‘˜å‡½æ•°
            std::function<std::string()> task = [this, frame_paths, j]() {
                return process_single_frame(frame_paths[j]);
            };

            // åˆ›å»ºpackaged_taskå¹¶è·å–future
            auto packaged_task = std::make_shared<std::packaged_task<std::string()>>(task);
            futures.push_back(packaged_task->get_future());

            // å°†ä»»åŠ¡æ·»åŠ åˆ°é˜Ÿåˆ—
            {
                std::unique_lock<std::mutex> lock(queue_mutex_);
                task_queue_.emplace([packaged_task]() { (*packaged_task)(); });
            }
            queue_condition_.notify_one();
        }

        // ç­‰å¾…å½“å‰æ‰¹æ¬¡å®Œæˆ
        for (size_t j = i; j < end_idx; ++j) {
            try {
                results.push_back(futures[j].get());
            } catch (const std::exception &e) {
                std::cerr << "å¤„ç†å¸§æ—¶å‡ºé”™: " << e.what() << std::endl;
                results.push_back(""); // æ·»åŠ ç©ºå­—ç¬¦ä¸²ä»¥ä¿æŒç´¢å¼•ä¸€è‡´æ€§
            }
        }
    }

    return results;
}
```

### 3. å†…å­˜å’Œèµ„æºä¼˜åŒ–

#### 3.1 ä¼˜åŒ–å¸§å¤„ç†å‡½æ•°

```cpp
// ä¼˜åŒ–process_single_frameå‡½æ•°ï¼Œå‡å°‘å†…å­˜æ‹·è´
std::string VideoKeyframeAnalyzer::process_single_frame(const std::string &frame_path)
{
    if (!std::filesystem::exists(frame_path)) {
        return "";
    }

    try {
        // è¯»å–å›¾åƒï¼Œä½¿ç”¨IMREAD_REDUCED_COLOR_2å‡å°‘å†…å­˜ä½¿ç”¨
        cv::Mat frame = cv::imread(frame_path, cv::IMREAD_REDUCED_COLOR_2);
        if (frame.empty()) {
            return "";
        }

        // è°ƒæ•´å›¾åƒå¤§å°ï¼Œä½¿ç”¨INTER_LINEAR_EXACTæé«˜è´¨é‡
        cv::Mat resized_frame;
        cv::resize(frame, resized_frame, cv::Size(800, 600), 0, 0, cv::INTER_LINEAR_EXACT);

        // é‡Šæ”¾åŸå§‹å›¾åƒå†…å­˜
        frame.release();

        // ç¼–ç ä¸ºJPEGå¹¶è½¬æ¢ä¸ºbase64
        std::vector<uchar> jpeg_data;
        std::vector<int> compression_params = {cv::IMWRITE_JPEG_QUALITY, 85};
        cv::imencode(".jpg", resized_frame, jpeg_data, compression_params);

        // é‡Šæ”¾è°ƒæ•´å¤§å°åçš„å›¾åƒå†…å­˜
        resized_frame.release();

        // ç›´æ¥ä»vectorè½¬æ¢ä¸ºbase64ï¼Œé¿å…é¢å¤–æ‹·è´
        std::string frame_base64 = utils::base64_encode(jpeg_data.data(), jpeg_data.size());

        return frame_base64;
    } catch (const std::exception &e) {
        std::cerr << "å¤„ç†å¸§ " << frame_path << " æ—¶å‡ºé”™: " << e.what() << std::endl;
        return "";
    }
}
```

#### 3.2 ä¼˜åŒ–Base64ç¼–ç 

```cpp
// åœ¨utils.hppä¸­æ·»åŠ ä¼˜åŒ–çš„base64ç¼–ç å‡½æ•°
namespace utils {
    // ä¼˜åŒ–çš„base64ç¼–ç å‡½æ•°ï¼Œé¿å…é¢å¤–å†…å­˜æ‹·è´
    inline std::string base64_encode(const unsigned char* data, size_t len) {
        static const std::string base64_chars = 
            "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
            "abcdefghijklmnopqrstuvwxyz"
            "0123456789+/";

        std::string ret;
        ret.reserve(((len + 2) / 3) * 4); // é¢„åˆ†é…ç©ºé—´ï¼Œé¿å…å¤šæ¬¡é‡æ–°åˆ†é…

        int i = 0;
        int j = 0;
        unsigned char char_array_3[3];
        unsigned char char_array_4[4];

        while (len--) {
            char_array_3[i++] = *(data++);
            if (i == 3) {
                char_array_4[0] = (char_array_3[0] & 0xfc) >> 2;
                char_array_4[1] = ((char_array_3[0] & 0x03) << 4) + ((char_array_3[1] & 0xf0) >> 4);
                char_array_4[2] = ((char_array_3[1] & 0x0f) << 2) + ((char_array_3[2] & 0xc0) >> 6);
                char_array_4[3] = char_array_3[2] & 0x3f;

                for(i = 0; (i <4) ; i++)
                    ret += base64_chars[char_array_4[i]];
                i = 0;
            }
        }

        if (i) {
            for(j = i; j < 3; j++)
                char_array_3[j] = ' ';

            char_array_4[0] = (char_array_3[0] & 0xfc) >> 2;
            char_array_4[1] = ((char_array_3[0] & 0x03) << 4) + ((char_array_3[1] & 0xf0) >> 4);
            char_array_4[2] = ((char_array_3[1] & 0x0f) << 2) + ((char_array_3[2] & 0xc0) >> 6);

            for (j = 0; (j < i + 1); j++)
                ret += base64_chars[char_array_4[j]];

            while((i++ < 3))
                ret += '=';
        }

        return ret;
    }
}
```

### 4. APIè¯·æ±‚ä¼˜åŒ–

#### 4.1 è¿æ¥æ± é¢„çƒ­å’Œä¿æŒæ´»è·ƒ

```cpp
// åœ¨CurlConnectionPoolä¸­æ·»åŠ é¢„çƒ­åŠŸèƒ½
class CurlConnectionPool {
public:
    // ... ç°æœ‰ä»£ç  ...

    // é¢„çƒ­è¿æ¥æ± 
    void warm_up(const std::string& api_url, int num_connections = 3) {
        std::cout << "ğŸ”¥ å¼€å§‹é¢„çƒ­è¿æ¥æ± ..." << std::endl;

        std::vector<std::future<bool>> futures;

        for (int i = 0; i < num_connections; ++i) {
            futures.push_back(std::async(std::launch::async, [this, api_url]() {
                try {
                    // åˆ›å»ºä¸€ä¸ªç®€å•çš„è¯·æ±‚æ¥é¢„çƒ­è¿æ¥
                    auto conn = get_connection();

                    // æ„å»ºä¸€ä¸ªæœ€å°åŒ–çš„å¥åº·æ£€æŸ¥è¯·æ±‚
                    nlohmann::json minimal_payload = {
                        {"model", "health-check"},
                        {"messages", nlohmann::json::array({{
                            {"role", "user"},
                            {"content", "ping"}
                        }})},
                        {"max_tokens", 1}
                    };

                    std::string payload_str = minimal_payload.dump();

                    // è®¾ç½®è¯·æ±‚é€‰é¡¹
                    curl_easy_setopt(conn.get(), CURLOPT_URL, api_url.c_str());
                    curl_easy_setopt(conn.get(), CURLOPT_POSTFIELDS, payload_str.c_str());

                    struct curl_slist* headers = nullptr;
                    headers = curl_slist_append(headers, "Content-Type: application/json");
                    curl_easy_setopt(conn.get(), CURLOPT_HTTPHEADER, headers);

                    // æ‰§è¡Œè¯·æ±‚
                    CURLcode res = curl_easy_perform(conn.get());

                    // æ¸…ç†
                    curl_slist_free_all(headers);

                    return res == CURLE_OK;
                } catch (const std::exception& e) {
                    std::cerr << "é¢„çƒ­è¿æ¥å¤±è´¥: " << e.what() << std::endl;
                    return false;
                }
            }));
        }

        // ç­‰å¾…æ‰€æœ‰é¢„çƒ­å®Œæˆ
        int success_count = 0;
        for (auto& future : futures) {
            try {
                if (future.get()) {
                    success_count++;
                }
            } catch (const std::exception& e) {
                std::cerr << "é¢„çƒ­ä»»åŠ¡å¼‚å¸¸: " << e.what() << std::endl;
            }
        }

        std::cout << "âœ… è¿æ¥æ± é¢„çƒ­å®Œæˆï¼ŒæˆåŠŸè¿æ¥: " << success_count << "/" << num_connections << std::endl;
    }
};
```

#### 4.2 ä¼˜åŒ–APIè¯·æ±‚é‡è¯•æœºåˆ¶

```cpp
// åœ¨DoubaoMediaAnalyzerä¸­ä¼˜åŒ–APIè¯·æ±‚å‡½æ•°
nlohmann::json DoubaoMediaAnalyzer::send_api_request(const nlohmann::json &payload, const std::string &model_name)
{
    const int max_retries = 3;
    const std::vector<int> retry_delays = {1000, 2000, 4000}; // æŒ‡æ•°é€€é¿

    for (int attempt = 0; attempt < max_retries; ++attempt) {
        try {
            // è·å–è¿æ¥
            auto conn = connection_pool_->get_connection();

            // è®¾ç½®è¯·æ±‚é€‰é¡¹
            std::string payload_str = payload.dump();
            std::string response_str;

            curl_easy_setopt(conn.get(), CURLOPT_URL, api_url_.c_str());
            curl_easy_setopt(conn.get(), CURLOPT_POSTFIELDS, payload_str.c_str());
            curl_easy_setopt(conn.get(), CURLOPT_WRITEFUNCTION, WriteCallback);
            curl_easy_setopt(conn.get(), CURLOPT_WRITEDATA, &response_str);

            // è®¾ç½®è¶…æ—¶
            curl_easy_setopt(conn.get(), CURLOPT_TIMEOUT, 60L);
            curl_easy_setopt(conn.get(), CURLOPT_CONNECTTIMEOUT, 10L);

            // æ‰§è¡Œè¯·æ±‚
            auto start_time = std::chrono::high_resolution_clock::now();
            CURLcode res = curl_easy_perform(conn.get());
            auto end_time = std::chrono::high_resolution_clock::now();

            // è®¡ç®—è¯·æ±‚æ—¶é—´
            auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end_time - start_time).count();

            // æ£€æŸ¥ç»“æœ
            if (res != CURLE_OK) {
                throw std::runtime_error("CURLè¯·æ±‚å¤±è´¥: " + std::string(curl_easy_strerror(res)));
            }

            // è§£æå“åº”
            auto response = nlohmann::json::parse(response_str);

            // è®°å½•æ€§èƒ½æ•°æ®
            std::cout << "â° [æ€§èƒ½] APIè¯·æ±‚å®Œæˆï¼Œæ€»è€—æ—¶: " << duration / 1000.0 << " ç§’" << std::endl;

            // æ£€æŸ¥å“åº”çŠ¶æ€
            if (response.contains("error")) {
                throw std::runtime_error("APIè¿”å›é”™è¯¯: " + response["error"].dump());
            }

            // æˆåŠŸï¼Œè¿”å›å“åº”
            return response;
        } catch (const std::exception& e) {
            std::cerr << "APIè¯·æ±‚å¤±è´¥ (å°è¯• " << (attempt + 1) << "/" << max_retries << "): " 
                      << e.what() << std::endl;

            // å¦‚æœä¸æ˜¯æœ€åä¸€æ¬¡å°è¯•ï¼Œåˆ™ç­‰å¾…åé‡è¯•
            if (attempt < max_retries - 1) {
                std::cout << "ç­‰å¾… " << retry_delays[attempt] << " æ¯«ç§’åé‡è¯•..." << std::endl;
                std::this_thread::sleep_for(std::chrono::milliseconds(retry_delays[attempt]));
            } else {
                // æ‰€æœ‰å°è¯•éƒ½å¤±è´¥ï¼ŒæŠ›å‡ºå¼‚å¸¸
                throw std::runtime_error("APIè¯·æ±‚å¤±è´¥ï¼Œå·²è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°: " + std::string(e.what()));
            }
        }
    }

    // ç†è®ºä¸Šä¸ä¼šåˆ°è¾¾è¿™é‡Œ
    throw std::runtime_error("æœªçŸ¥çš„APIè¯·æ±‚é”™è¯¯");
}
```

## é¢„æœŸæ•ˆæœ

å®æ–½ä»¥ä¸Šä¼˜åŒ–åï¼Œé¢„æœŸå¯ä»¥è¾¾åˆ°ä»¥ä¸‹æ•ˆæœï¼š

1. **è§†é¢‘å¤„ç†é€Ÿåº¦æå‡2-3å€**ï¼šé€šè¿‡ä¼˜åŒ–FFmpegå‚æ•°å’Œå¹¶å‘å¤„ç†ï¼Œå¸§æå–æ—¶é—´å¯ä»2-3ç§’é™ä½åˆ°0.5-1ç§’ã€‚
2. **APIè¯·æ±‚å»¶è¿Ÿé™ä½50%**ï¼šé€šè¿‡è¿æ¥æ± é¢„çƒ­å’Œä¼˜åŒ–é‡è¯•æœºåˆ¶ï¼Œé¦–æ¬¡è¯·æ±‚å»¶è¿Ÿå¯ä»10ç§’é™ä½åˆ°5ç§’ä»¥ä¸‹ã€‚
3. **èµ„æºåˆ©ç”¨ç‡æé«˜30%**ï¼šé€šè¿‡ä¼˜åŒ–çº¿ç¨‹æ± å’Œå†…å­˜ç®¡ç†ï¼Œç³»ç»Ÿèµ„æºåˆ©ç”¨ç‡å°†æ˜¾è‘—æé«˜ã€‚
4. **ç³»ç»Ÿç¨³å®šæ€§å¢å¼º**ï¼šé€šè¿‡æ·»åŠ é‡è¯•æœºåˆ¶å’Œé”™è¯¯å¤„ç†ï¼Œç³»ç»Ÿç¨³å®šæ€§å°†å¾—åˆ°å¢å¼ºã€‚

## å®æ–½è®¡åˆ’

### é˜¶æ®µä¸€ï¼šFFmpegå‘½ä»¤ä¼˜åŒ–ï¼ˆ1-2å¤©ï¼‰

1. å®ç°get_optimized_extract_cmdå‡½æ•°
2. ä¿®æ”¹extract_keyframeså‡½æ•°ï¼Œæ ¹æ®è§†é¢‘æ—¶é•¿åŠ¨æ€è°ƒæ•´é‡‡æ ·ç­–ç•¥
3. æµ‹è¯•ä¸åŒç±»å‹è§†é¢‘çš„å¤„ç†æ•ˆæœ

### é˜¶æ®µäºŒï¼šå¹¶å‘å’Œçº¿ç¨‹æ± ä¼˜åŒ–ï¼ˆ2-3å¤©ï¼‰

1. ä¼˜åŒ–çº¿ç¨‹æ± åˆå§‹åŒ–å’Œé…ç½®
2. æ”¹è¿›å¸§å¤„ç†å¹¶å‘é€»è¾‘
3. æµ‹è¯•ä¸åŒå¹¶å‘åœºæ™¯ä¸‹çš„æ€§èƒ½è¡¨ç°

### é˜¶æ®µä¸‰ï¼šå†…å­˜å’Œèµ„æºä¼˜åŒ–ï¼ˆ2-3å¤©ï¼‰

1. ä¼˜åŒ–å¸§å¤„ç†å‡½æ•°ï¼Œå‡å°‘å†…å­˜æ‹·è´
2. æ”¹è¿›Base64ç¼–ç å®ç°
3. æµ‹è¯•å†…å­˜ä½¿ç”¨æƒ…å†µ

### é˜¶æ®µå››ï¼šAPIè¯·æ±‚ä¼˜åŒ–ï¼ˆ2-3å¤©ï¼‰

1. å®ç°è¿æ¥æ± é¢„çƒ­åŠŸèƒ½
2. ä¼˜åŒ–APIè¯·æ±‚é‡è¯•æœºåˆ¶
3. æµ‹è¯•APIè¯·æ±‚æ€§èƒ½å’Œç¨³å®šæ€§

## æ€»ç»“

æœ¬ä¼˜åŒ–æ–¹æ¡ˆé’ˆå¯¹è±†åŒ…åª’ä½“åˆ†æAPIæœåŠ¡å™¨çš„è§†é¢‘å¤„ç†æ€§èƒ½ç“¶é¢ˆï¼Œæå‡ºäº†ä»FFmpegå‘½ä»¤ã€å¹¶å‘å¤„ç†ã€å†…å­˜ç®¡ç†åˆ°APIè¯·æ±‚çš„å…¨æ–¹ä½ä¼˜åŒ–ç­–ç•¥ã€‚é€šè¿‡åˆ†é˜¶æ®µå®æ–½è¿™äº›ä¼˜åŒ–æªæ–½ï¼Œé¢„æœŸå¯ä»¥æ˜¾è‘—æé«˜è§†é¢‘å¤„ç†é€Ÿåº¦ï¼Œé™ä½èµ„æºæ¶ˆè€—ï¼Œæå‡ç”¨æˆ·ä½“éªŒå’Œç³»ç»Ÿç¨³å®šæ€§ã€‚

åœ¨å®æ–½è¿‡ç¨‹ä¸­ï¼Œå»ºè®®æŒç»­ç›‘æ§ç³»ç»Ÿæ€§èƒ½æŒ‡æ ‡ï¼Œæ ¹æ®å®é™…æƒ…å†µè°ƒæ•´ä¼˜åŒ–å‚æ•°ï¼Œç¡®ä¿ä¼˜åŒ–æ•ˆæœæœ€å¤§åŒ–ã€‚åŒæ—¶ï¼Œä¿æŒä»£ç çš„å¯ç»´æŠ¤æ€§å’Œå¯æ‰©å±•æ€§ï¼Œä¸ºæœªæ¥çš„åŠŸèƒ½æ‰©å±•å’Œæ€§èƒ½ä¼˜åŒ–å¥ å®šè‰¯å¥½åŸºç¡€ã€‚
